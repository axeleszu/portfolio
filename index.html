<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axel Escutia Zubieta</title>
    <style>
        :root {
            --terminal-color: #00f3ff;
            --terminal-bg: rgba(0, 15, 30, 0.75);
            --success: #28a745;
            --fail: #ff3333;
        }

        body,
        html {
            height: 100%;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
        }

        .bg-container {
            background: linear-gradient(135deg, #1c2a4f, #2657c5);
            height: 100%;
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            position: relative;
        }

        .bg-container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .content {
            text-align: center;
            padding: 20px;
            width: 100%;
            max-width: 700px;
        }

        .content h1 {
            font-size: 48px;
            margin-bottom: 5px;
            font-weight: 300;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .content p {
            font-size: 20px;
            font-weight: 300;
            margin-bottom: 30px;
            opacity: 0.9;
        }


        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: gray;
            border-radius: 50%;
            margin-left: 10px;
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        .status-active {
            background-color: var(--success);
            box-shadow: 0 0 15px var(--success);
            animation: pulse 2s infinite;
        }

        .status-down {
            background-color: var(--fail);
            box-shadow: 0 0 15px var(--fail);
            animation: fast-blink 0.5s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes fast-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .terminal-window {
            background: var(--terminal-bg);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', Courier, monospace;
            text-align: left;
            font-size: 14px;
            color: var(--terminal-color);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            min-height: 200px;
            position: relative;
            overflow: hidden;
        }

        .terminal-window::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--terminal-color), transparent);
            animation: scan 4s linear infinite;
        }

        @keyframes scan {
            0% {
                left: -100%;
            }

            100% {
                left: 100%;
            }
        }

        .terminal-header {
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
            justify-content: space-between;
            font-weight: bold;
            opacity: 0.8;
        }

        .terminal-header span {
            display: block;
            white-space: pre-wrap;
        }

        #console-output {
            white-space: pre-wrap;
            line-height: 1.5;
            height: 150px;
            overflow-y: auto;
        }

        #console-output::-webkit-scrollbar {
            width: 5px;
        }

        #console-output::-webkit-scrollbar-thumb {
            background: var(--terminal-color);
            border-radius: 3px;
        }

        .latency-text {
            float: right;
        }

        .cursor {
            display: inline-block;
            width: 8px;
            height: 15px;
            background: var(--terminal-color);
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .longwait {
            color: #00d3ff;
        }
    </style>
</head>

<body>

    <div class="bg-container">
        <div class="overlay">
            <div class="content">
                <div class="terminal-window">
                    <div class="terminal-header">

                        <span>Axel Escutia' Server </span>
                        <span>LOCALHOST PORT 80 - Apache </span>
                        <span id="latency-display">LATENCY: --</span>
                    </div>
                    <div id="console-output"></div>
                    <span class="cursor"></span>
                </div>
                <p>Estado del sistema: <span id="main-status-text">Analizando...</span> <span id="status-dot" class="status-indicator"></span></p>
            </div>
        </div>
    </div>

    <script>
        const output = document.getElementById('console-output');
        const latencyDisplay = document.getElementById('latency-display');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('main-status-text');


        const runSystemCheck = async () => {
            await typeLine('> CHECKING LOCALHOST INTEGRITY...', 10);
            // Artificial delay 
            await new Promise(r => setTimeout(r, 800));
            await typeLine('> SENDING PACKET TO GATEWAY...', 10);

            // Perform the real test
            const result = await pingServer();

            if (result.status === 'OK') {
                // TERMINAL OUTPUT
                let ms = result.time;
                await typeLine('> CONNECTION ESTABLISHED. LATENCY: ' + ms + 'ms');
                await typeLine('> HARDWARE INFO...', 20);

                await new Promise(r => setTimeout(r, 500));
                await typeLine('> SERVER STATUS: ONLINE', 10, 'var(--success)');

                statusDot.className = 'status-indicator status-active';
                statusText.innerText = "Activo";
                statusText.style.color = "#fff";

                latencyDisplay.textContent = 'LATENCY:' + ms + 'ms';

                const hardwareInfo = getClientHardware();
                await typeLine('>> DETECTED: [' + hardwareInfo + ']', 10);

                const netInfo = getNetworkDetails();
                await typeLine('>> CHECKING NETWORK CONNECTION...', 10);
                await typeLine('>> DETECTED: ' + netInfo, 10);

                const timeData = await checkTimeSync();
                await typeLine('>> CLOCK OFFSET: ' + timeData, 10);

                const metrics = getBootMetrics();
                if (metrics) {
                    await typeLine('>> COLLECTING BOOT METRICS...', 10);
                    // Loop through the array to print lines
                    for (let i = 0; i < metrics.length; i++) {
                        await typeLine('>>> [METRIC] ' + metrics[i], 5);
                    }
                }

                const identity = identifyUser();

                if (identity.count > 1) {
                    await typeLine('>> USER IDENTIFIED , ' + identity.id + '. ACCESS LOG COUNT: ' + identity.count, 20);
                } else {
                    await typeLine('>> NEW USER IDENTIFIED. WELCOME!! | ID: ' + identity.id, 20);
                }

                const ipData = await checkIpData();

                await typeLine('>> TRACING IP DATA: ' + ipData, 10, 'yellow');

                const weather = await checkOpenMeteo();
                await typeLine('>> WEATHER DATA: ' + weather, 10, 'gray');


                const jotd = await getGeekJokeOfTheDay();
                if (jotd) {

                    await typeLine('>> ' + jotd, 30, 'white');
                }

                await typeLine('>> PROCESSING...', 20);

                // Start the timer (no await, let it run in background)
                startLongWait();


                // Start Heartbeat Loop
                setInterval(async () => {
                    const beat = await pingServer();
                    if (beat.status === 'OK') {
                        latencyDisplay.textContent = 'LATENCY: ' + ms + 'ms';
                        latencyDisplay.style.color = '#00f3ff';
                    } else {
                        latencyDisplay.textContent = `CONNECTION LOST`;
                        latencyDisplay.style.color = '#ff3333';
                        statusDot.className = 'status-indicator status-down';
                    }
                }, 3000);

            } else {
                // FAILURE STATE
                await typeLine('> ERROR: HOST UNREACHABLE (CODE: ' + result.status + ')', 20, '#ff3333');
                await typeLine('> RETRYING...', 50, '#ff3333');

                statusDot.className = 'status-indicator status-down';
                statusText.innerText = "Desconectado";
                statusText.style.color = "#ff3333";
                latencyDisplay.textContent = "OFFLINE";
                latencyDisplay.style.color = "#ff3333";
            }
        };

        // Typewriter function
        const typeLine = (text, delay = 20, color = 'var(--terminal-color)') => {
            return new Promise(resolve => {
                const line = document.createElement('div');
                line.style.color = color;
                output.appendChild(line);

                let i = 0;
                const interval = setInterval(() => {
                    line.textContent += text.charAt(i);
                    i++;
                    output.scrollTop = output.scrollHeight;
                    if (i > text.length - 1) {
                        clearInterval(interval);
                        resolve();
                    }
                }, delay);
            });
        };

        const pingServer = async () => {
            const start = Date.now();
            try {
                const response = await fetch(window.location.href + '?t=' + Date.now(), {
                    method: 'HEAD',
                    cache: 'no-store'
                });
                const duration = Date.now() - start;
                return response.ok ? { status: 'OK', time: duration } : { status: 'ERR', time: duration };
            } catch (e) {
                return { status: 'DOWN', time: 0 };
            }
        };

        const getClientHardware = () => {
            const cores = navigator.hardwareConcurrency || '?';
            const ram = navigator.deviceMemory ? '~' + navigator.deviceMemory + ' GB' : 'N/A';
            return 'CPU: ' + cores + ' CORES | RAM: ' + ram;
        }
        const getNetworkDetails = () => {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

            if (conn) {
                const speed = conn.downlink ? conn.downlink + ' Mbps' : 'UNKNOWN';
                const type = conn.effectiveType ? conn.effectiveType.toUpperCase() : 'UNKNOWN';

                return 'TYPE: ' + type + ' | SPEED: ~' + speed;
            }
            return 'NETWORK INFO UNAVAILABLE';
        };

        const checkTimeSync = async () => {
            try {
                // We make a HEAD request just to check headers
                const response = await fetch(window.location.href + '?sync=' + Date.now(), { method: 'HEAD' });

                // Get server time string and convert to milliseconds
                const serverDateStr = response.headers.get('date');
                const serverTime = new Date(serverDateStr).getTime();
                const clientTime = Date.now();

                // Calculate difference in seconds
                const drift = Math.floor((clientTime - serverTime) / 1000);

                // Determine symbol (+ or -)
                const sign = drift >= 0 ? '+' : '';

                return 'OFFSET: ' + sign + drift + 's (SERVER: ' + serverDateStr + ')';
            } catch (e) {
                return 'SYNC FAILED';
            }
        };

        const getBootMetrics = () => {
            // Get the performance stats for the current page load
            const perf = performance.getEntriesByType("navigation")[0];

            if (!perf) return null;

            // Calculate specific phases (fallback to 0 if info is missing)
            const dns = (perf.domainLookupEnd - perf.domainLookupStart).toFixed(2);
            const tcp = (perf.connectEnd - perf.connectStart).toFixed(2);
            const duration = perf.duration.toFixed(2);

            return [
                'DNS LOOKUP: ' + dns + 'ms',
                'TCP HANDSHAKE: ' + tcp + 'ms',
                'TOTAL LOAD: ' + duration + 'ms'
            ];
        };

        const identifyUser = () => {
            // Try to get existing ID
            let userId = localStorage.getItem('terminal_user_id');
            let visits = localStorage.getItem('terminal_visit_count');

            // If no ID, generate a random hex string
            if (!userId) {
                userId = 'USR-' + Math.floor(Math.random() * 0xFFFFFF).toString(16).toUpperCase();
                visits = 1;
                localStorage.setItem('terminal_user_id', userId);
            } else {
                // Increment visit count (parse to Int first because localStorage stores strings)
                visits = parseInt(visits) + 1;
            }

            // Save new count
            localStorage.setItem('terminal_visit_count', visits);

            return { id: userId, count: visits };
        };

        const checkIpData = async () => {
            try {
                const response = await fetch('https://ipwho.is/');
                const data = await response.json();

                if (!data.success) return 'RED P\u00DALICA: NO DISPONIBLE';

                return 'IP: ' + data.ip + ' | ISP: ' + data.connection.isp + ' | LOC: ' + data.city + ', ' + data.country_code;
            } catch (e) {
                return 'RED P\u00DALICA: ERROR DE CONEXI\u00D3N';
            }
        };

        const checkOpenMeteo = async () => {
            try {
                const locResponse = await fetch('https://ipwho.is/');
                const locData = await locResponse.json();

                if (!locData.success) return 'UBICACION: FALLO EN TRIANGULACION';

                const lat = locData.latitude;
                const lon = locData.longitude;
                const city = locData.city;

                const weatherUrl = 'https://api.open-meteo.com/v1/forecast?latitude=' + lat + '&longitude=' + lon + '&current_weather=true';

                const wResponse = await fetch(weatherUrl);
                const wData = await wResponse.json();
                const current = wData.current_weather;
                let icon = '';
                const code = current.weathercode;

                if (code === 0) icon = '\u2600\uFE0F'; // Sun
                else if (code >= 1 && code <= 3) icon = '\u26C5'; // Part Cloudy
                else if (code >= 45 && code <= 48) icon = '\uD83C\uDF2B\uFE0F'; // Fog
                else if (code >= 51 && code <= 67) icon = '\uD83C\uDF27\uFE0F'; // Rain
                else if (code >= 71 && code <= 77) icon = '\u2744\uFE0F'; // Snow
                else if (code >= 95) icon = '\u26C8\uFE0F'; // Thunderstorm
                else icon = '\uD83C\uDF25\uFE0F'; // Cloudy/Windy default

                // Build the string
                return 'WEATHER: ' + city.toUpperCase() + ' ' + icon + ' ' + current.temperature + '\u00B0C (WIND: ' + current.windspeed + ' km/h)';

            } catch (e) {
                return 'WHEATHER SERVER ERROR';
            }
        };
        const getGeekJokeOfTheDay = async () => {
            try {
                // Request a single-line programming joke
                const url = 'https://v2.jokeapi.dev/joke/Programming?blacklistFlags=nsfw,religious,political,racist,sexist&type=single';
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) return null;

                return 'GEEK JOKE: ' + data.joke.toUpperCase();
            } catch (e) {
                return null;
            }
        };

        const triggerMatrixEffect = () => {
            // 1. Create the Canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '9999'; // On top of everything
            canvas.style.background = 'black';
            canvas.style.opacity = '0'; // Start invisible
            canvas.style.transition = 'opacity 2s';

            document.body.appendChild(canvas);

            // 2. Setup Dimensions
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // 3. Matrix Logic
            let letters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';

            for (let i = 0x30A0; i <= 0x30FF; i++) {
                letters += String.fromCharCode(i);
            }

            const fontSize = 16;
            const columns = canvas.width / fontSize;
            const drops = [];

            for (let x = 0; x < columns; x++) {
                drops[x] = 1;
            }

            // 4. Draw Function
            const draw = () => {
                // Semi-transparent black to create "trails"
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#00f3ff';
                ctx.font = fontSize + 'px monospace';

                for (let i = 0; i < drops.length; i++) {
                    const text = letters.charAt(Math.floor(Math.random() * letters.length));
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                    // Randomly reset drop to top
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
                requestAnimationFrame(draw);
            };

            setTimeout(function () {
                canvas.style.opacity = '1';
                draw();
            }, 100);
        };

        const startLongWait = () => {
            const totalMinutes = 1;
            const totalTime = totalMinutes * 60 * 1000;

            const barLength = 20;
            const startTime = Date.now();

            const line = document.createElement('div');
            line.className = 'longwait';
            output.appendChild(line);

            output.scrollTop = output.scrollHeight;

            const timer = setInterval(function () {
                const elapsed = Date.now() - startTime;
                let percent = elapsed / totalTime;

                if (percent >= 1) {
                    percent = 1;
                    clearInterval(timer);

                    line.textContent = '> UPLOAD COMPLETE [====================] 100%';
                    output.scrollTop = output.scrollHeight;

                    // PRIZE TRIGGER
                    setTimeout(function () {
                        typeLine('> SYSTEM OVERRIDE DETECTED...', 10, 'warn');
                        typeLine('> ROOT ACCESS GRANTED.', 10, '#00d3ff;');
                        setTimeout(triggerMatrixEffect, 2000);
                    }, 1000);
                    return;
                }

                // Build the visual bar
                const filledLen = Math.round(barLength * percent);
                const emptyLen = barLength - filledLen;

                let barStr = '';
                for (let i = 0; i < filledLen; i++) barStr += '=';
                for (let i = 0; i < emptyLen; i++) barStr += '.';

                const pctStr = Math.floor(percent * 100);

                // Update text
                line.textContent = '> UPLOADING DATA TO SERVER [' + barStr + '] ' + pctStr + '%';
                output.scrollTop = output.scrollHeight;

            }, 1000);
        };

        window.onload = runSystemCheck;
    </script>
</body>

</html>